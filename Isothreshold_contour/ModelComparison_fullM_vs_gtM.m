clear all; close all; clc
%Load the ground truth (simulated using CIELab)
load('Isothreshold_contour_CIELABderived.mat', 'D');
param   = D{1};
stim    = D{2};
results = D{3};
plt     = D{4};

%we have a total of nDataFiles, each of which was generated by a different
%seed
nDataFiles     = 10; %10
plane_slc      = 'GB plane';
numSimPerCond  = 80;%40, 80, 240,480
samplingMethod = 'NearContour'; %'Random'; 'NearContour'
samplingJitter = 0.1;   %applicable only for 'NearContour'
samplingRange  = 0.025; %applicable only for 'Random'
analysisDir    = getpref('ColorEllipsoids', 'ELPSAnalysis');
myDataDir      = 'Simulation_DataFiles/DataFiles_HPC';
intendedDir    = fullfile(analysisDir, myDataDir);
addpath(intendedDir);

%% Fit the full model
%this model has 3 free parameters: (1) major axis (2) minor axis (3) angle (in deg)
fits.num_free_param = 3;
fits.lb             = [1,1,0];
%the angle is in between 0 and 90 deg based on observations
fits.ub             = [500,500,90]; 
% Linear inequality constraints
fits.inequality_A   = [1, -1, 0];
fits.inequality_b   = 0;
%the ratio of major vs. minor axis is less than 7 based on observations
fits.nonlcon        = @(x) deal(x(2)/x(1) - 7, []); 
%have different initial points to avoid fmincon from getting stuck at
%some places
fits.N_runs         = 10;
fits.init           = rand(fits.N_runs,fits.num_free_param).*(fits.ub- fits.lb) + fits.lb;
fits.contour_scaler = 5;
options             = optimoptions(@fmincon, 'MaxIterations', 1e5, 'Display','off');

for s = 1:nDataFiles
    disp(s)
    %load simulated data generated using different seeds
    if nDataFiles > 1; str_extension = ['_rng',num2str(s)]; 
    else; str_extension = ''; end
    if strcmp(samplingMethod, 'NearContour')
        load(['Sims_isothreshold_',plane_slc,'_sim',num2str(numSimPerCond),...
            'perCond_sampling',samplingMethod,'_jitter',num2str(samplingJitter),...
            str_extension,'.mat'], 'sim'); 
    elseif strcmp(samplingMethod, 'Random')
        load(['Sims_isothreshold_',plane_slc,'_sim',num2str(numSimPerCond),...
            'perCond_sampling',samplingMethod,'_range',num2str(samplingRange),...
            str_extension,'.mat'], 'sim');      
    end

    %for each reference stimulus
    for i = 1:stim.nGridPts_ref  
        for j = 1:stim.nGridPts_ref 
            %get the ref stimulus 
            rgb_ref_ij = squeeze(sim.ref_points(i,j,sim.varying_RGBplane));

            %define the objective function
            objectiveFunc_fullM = @(ellPara) estimate_loglikelihood_individualEllipses(...
                ellPara, rgb_ref_ij, squeeze(sim.rgb_comp(i,j,sim.varying_RGBplane,:)),...
                sim.alpha, sim.beta, squeeze(sim.resp_binary(i,j,:)));

            %fit the full model
            for n = 1:fits.N_runs    
                %use fmincon to search for the optimal defocus
                [fits.ellParam_est(i,j,n,:,s), fits.nLL(i,j,n,s)] = ...
                    fmincon(objectiveFunc_fullM, fits.init(n,:), ...
                    fits.inequality_A,fits.inequality_b,[],[],fits.lb,...
                    fits.ub,fits.nonlcon,options);
                %there is an additional constraint, major axis > minor axis
            end
            %find the index that corresponds to the minimum value
            [fits.nLL_best(i,j,s),idx_min] = min(fits.nLL(i,j,:,s));

            %find the parameters corresponding to the minimum nLL
            fits.ellParam_est_best(i,j,:,s)  = squeeze(fits.ellParam_est(i,j,idx_min,:,s));

            %compute matrix Q given the best-fitting parameters
            fits.Q(i,j,:,:,s) = computeQ_givenEllParam(fits.ellParam_est_best(i,j,1,s),...
                fits.ellParam_est_best(i,j,2,s),fits.ellParam_est_best(i,j,3,s));

            %unscaled ellipse
            fits.fullM_fitEllipse_unscaled(i,j,:,:,s) =...
                PointsOnEllipseQ(squeeze(fits.Q(i,j,:,:,s)), plt.circleIn2D)' + ...
                rgb_ref_ij';

            %scaled ellipse
            fits.fullM_fitEllipse_scaled(i,j,:,:,s) = ...
                (squeeze(fits.fullM_fitEllipse_unscaled(i,j,:,:,s)) - ...
                rgb_ref_ij').*fits.contour_scaler + rgb_ref_ij';
        end
    end
    %calculate the summed nLL across all reference locations
    fits.nLL_allRef(s) = sum(sum(fits.nLL_best(:,:,s)));
end

%% compute the mean and error bars
if nDataFiles > 1
    %ideally we want to find indices that correspond to 2.5% and 97.5%
    %confidence intervals, but since the simulation datasets are limited,
    %we are unlikely to do that. Instead, we can just show the whole range
    errbar_lb_idx = 1;
    errbar_ub_idx = nDataFiles;

    %axis ratio
    axisRatio_fullM = squeeze((1/fits.ellParam_est_best(:,:,1,:))./...
        (1/fits.ellParam_est_best(:,:,2,:)));
    for i = 1:stim.nGridPts_ref  
        for j = 1:stim.nGridPts_ref  
            %axis ratio
            axisRatio_fullM_sorted = squeeze(sort(axisRatio_fullM(i,j,:), 'ascend'));
            fits.axisRatio_fullM_mean(i,j) = mean(axisRatio_fullM_sorted);
            fits.axisRatio_fullM_lb(i,j) = axisRatio_fullM_sorted(errbar_lb_idx);
            fits.axisRatio_fullM_ub(i,j) = axisRatio_fullM_sorted(errbar_ub_idx);
            
            %rotation angle
            rotAngle_fullM = deg2rad(squeeze(fits.ellParam_est_best(i,j,3,:)));
            rotAngle_fullM_sorted = sort(rotAngle_fullM, 'ascend');
            fits.rotAngle_fullM_mean(i,j) = mean(rotAngle_fullM_sorted);
            fits.rotAngle_fullM_lb(i,j) = rotAngle_fullM_sorted(errbar_lb_idx);
            fits.rotAngle_fullM_ub(i,j) = rotAngle_fullM_sorted(errbar_ub_idx); 
    
            %get a confidence interval
            [fits.unscaled_contour_CI_ub_fullM(i,j,:,:),...
                fits.unscaled_contour_CI_lb_fullM(i,j,:,:),...
                fits.contour_CI_ub_fullM(i,j,:,:), fits.contour_CI_lb_fullM(i,j,:,:)] = ...
                compute_contour_CI(squeeze(fits.fullM_fitEllipse_unscaled(i,j,:,:,:)),...
                [stim.x_grid_ref(i,j), stim.y_grid_ref(i,j)]);
        end
    end
end

%ground truth ellipses
gtM_fitEllipse_unscaled = squeeze(...
    results.fitEllipse_unscaled(sim.slc_fixedVal_idx,...
    sim.slc_RGBplane,:,:,:,:));
gtM_ellParam = squeeze(results.ellParams(sim.slc_fixedVal_idx,...
    sim.slc_RGBplane, :, :,:));

%% visualize model fits with samples of the comparison stimulus
plt.ttl = {'GB plane', 'RB plane', 'RG plane'};
if strcmp(sim.method_sampling,'NearContour')
    fig_str = [plt.ttl{sim.slc_RGBplane},...
        '_sim',num2str(sim.nSims), 'perCond_sampling',sim.method_sampling,...
        '_jitter',num2str(sim.random_jitter)];
elseif strcmp(sim.method_sampling, 'Random')
    fig_str  = [plt.ttl{sim.slc_RGBplane},...
        '_sim',num2str(sim.nSims), 'perCond_sampling',sim.method_sampling,...
        '_range',num2str(sim.range_randomSampling(end))];
end

groundTruth_slc = squeeze(results.fitEllipse_unscaled(sim.slc_fixedVal_idx,...
    sim.slc_RGBplane,:,:,:,:));
for s = 1:nDataFiles
    plot_2D_sampledComp(stim.grid_ref, stim.grid_ref, sim.rgb_comp, ...
        sim.varying_RGBplane,'NearContour',...
        'EllipsesColor',[178,34,34]./255,...
        'WishartEllipsesColor',[76,153,0]./255,...
        'responses', sim.resp_binary,...
        'groundTruth',groundTruth_slc,...
        'modelPredictions', squeeze(fits.fullM_fitEllipse_unscaled(:,:,:,:,s)), ...
        'lineWidth',2,...
        'saveFig',false,...
        'figName',['Fitted_Isothreshold_contour_fullM_',fig_str, '_rng',num2str(s)]);    
end

%% visualize the model predictions with confidence intervals
plot_2D_isothreshold_contour(stim.x_grid_ref, stim.y_grid_ref, ...
    results.fitEllipse(sim.slc_fixedVal_idx,...
    sim.slc_RGBplane,:,:,:,:),sim.slc_fixedVal,...
    'slc_x_grid_ref',1:length(stim.grid_ref),...
    'slc_y_grid_ref',1:length(stim.grid_ref),...
    'WishartEllipses_contour_CI',{},...
    'IndividualEllipses_contour_CI',{fits.contour_CI_lb_fullM, fits.contour_CI_ub_fullM},...
    'rgb_background',false,...
    'xlabel',plane_slc(1),...
    'ylabel',plane_slc(2),...
    'refColor',[0,0,0],...
    'EllipsesColor',[178,34,34]./255,...
    'WishartEllipsesColor',[76,153,0]./255,...
    'ExtrapEllipsesColor',[0.5,0.5,0.5],...
    'figPos',[0,0.1,0.35,0.4],...
    'subTitle', {sprintf(['Comparison of the predictions for the iso-threshold contours \nin ',...
        plane_slc, ' between the full model and the ground truth'])},...
    'figName', ['Comparison_IsothresholdContours_fullM_vs_gtM_',fig_str,...
            '_rng1to',num2str(nDataFiles)],...
    'saveFig',false);

%% visualize the comparison between the full model and the ground truth model
%ratio between major and minor axis
plot_comparison_WishartM_vs_fullM(squeeze(gtM_ellParam(:,:,2))./squeeze(gtM_ellParam(:,:,1)),...
    fits.axisRatio_fullM_mean,fits.axisRatio_fullM_lb,...
    fits.axisRatio_fullM_ub,[],[],...
    'xlim',[1,7],'ylim',[1,7],'x_ref',stim.grid_ref,'y_ref',stim.grid_ref,...
    'xlabel',sprintf('The ground-truth ratio of major vs. minor axis'),...
    'ylabel',sprintf('The ratio of major vs. minor axis\n computed based on the Full Model'),...
    'figPos',[0,0.1,0.3,0.5],'paperSize',[25,25],'saveFig', false,'figName',...
    ['Comparison_axisRatio_fullM_vs_gtM_',fig_str, '_rng1to',num2str(nDataFiles)]);

%rotation angle
plot_comparison_WishartM_vs_fullM(squeeze(deg2rad(gtM_ellParam(:,:,3))),...
    fits.rotAngle_fullM_mean,fits.rotAngle_fullM_lb,...
    fits.rotAngle_fullM_ub,[],[],...
    'xlim',[0,pi/2],'ylim',[0,pi/2],'x_ref',stim.grid_ref,'y_ref',stim.grid_ref,...
    'xticks',0:pi/8:pi/2, 'yticks',0:pi/8:pi/2, ...
    'xticklabels',{'$0$','$\pi/8$','$\pi/4$','$3\pi/8$','$\pi/2$'},...
    'yticklabels',{'$0$','$\pi/8$','$\pi/4$','$3\pi/8$','$\pi/2$'},...
    'LatexInterpreter',true,...
    'xlabel',sprintf('The ground-truth rotation (in radians)'),...
    'ylabel',sprintf('The rotation (in radians)\n computed based on the Full Model'),...
    'figPos',[0,0.1,0.3,0.5],'paperSize',[25,25],'saveFig', false,'figName',...
    ['Comparison_rotAngle_fullM_vs_gtM_',fig_str, '_rng1to',num2str(nDataFiles)]);


%% save data
analysisDir = getpref('ColorEllipsoids', 'ELPSAnalysis');
myFigDir = 'ModelComparison_DataFiles';
outputDir = fullfile(analysisDir,myFigDir);
if (~exist('outputDir'))
    mkdir(outputDir);
end

%whether we want to save the seed
flag_saveSeed = true;
if flag_saveSeed; str_extension = ['_rng1to', num2str(nDataFiles)];
else; str_extension = ''; end

if strcmp(sim.method_sampling, 'NearContour')
    fileName = ['Comparison_fullM_vs_gtM_',plt.ttl{sim.slc_RGBplane},'_sim',...
        num2str(sim.nSims), 'perCond_sampling',sim.method_sampling,...
        '_jitter',num2str(sim.random_jitter),str_extension,'.mat'];
elseif strcmp(sim.method_sampling, 'Random')
    fileName = ['Comparison_fullM_vs_gtM_',plt.ttl{sim.slc_RGBplane},'_sim',...
        num2str(sim.nSims), 'perCond_sampling',sim.method_sampling,...
        '_range',num2str(sim.range_randomSampling(end)),str_extension,'.mat'];
end
outputName = fullfile(outputDir, fileName);
save(outputName,'fits');








