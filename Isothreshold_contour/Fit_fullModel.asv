clear all; close all; clc
%Load data grabbed from hpc and analyze the goodness of fits of ellipses
load('Isothreshold_contour_CIELABderived.mat', 'D');
param   = D{1};
stim    = D{2};
results = D{3};
plt     = D{4};

%we have a total of nDataFiles, each of which was generated by a different
%seed
nDataFiles     = 10;
plane_slc      = 'GB plane';
numSimPerCond  = 480;
samplingMethod = 'NearContour'; %'NearContour';
samplingJitter = 0.1;
samplingRange  = 0.025;
analysisDir    = getpref('ColorEllipsoids', 'ELPSAnalysis');
myDataDir      = 'Simulation_DataFiles/DataFiles_HPC';
intendedDir    = fullfile(analysisDir, myDataDir);
addpath(intendedDir);

%% have different initial points to avoid fmincon from getting stuck at
%some places
fits.num_free_param = 3;
fits.lb      = [1,1,0];
fits.ub      = [500,500,360];
fits.nonlcon = @(x) deal(x(2)/x(1) - 7, []);
fits.N_runs  = 10;
fits.init    = rand(fits.N_runs,fits.num_free_param).*(fits.ub- fits.lb) + fits.lb;
fits.contour_scaler = 5;
options = optimoptions(@fmincon, 'MaxIterations', 1e5, 'Display','off');

for s = 1:nDataFiles
    disp(s)
    if strcmp(samplingMethod, 'NearContour')
        load(['Sims_isothreshold_',plane_slc,'_sim',num2str(numSimPerCond),...
            'perCond_sampling',samplingMethod,'_jitter',num2str(samplingJitter),...
            '_rng',num2str(s),'.mat'], 'sim');%'_rng',num2str(s),
    elseif strcmp(samplingMethod, 'Random')
        load(['Sims_isothreshold_',plane_slc,'_sim',num2str(numSimPerCond),...
            'perCond_sampling',samplingMethod,'_range',num2str(samplingRange),...
            '_rng',num2str(s),'.mat'], 'sim');      %'_rng',num2str(s),
    end

    %for each reference stimulus
    for i = 1:stim.nGridPts_ref  
        for j = 1:stim.nGridPts_ref 
            %fit the full model
            objectiveFunc_fullM = @(ellPara) estimate_loglikelihood_individualEllipses(...
                ellPara, squeeze(sim.ref_points(i,j,sim.varying_RGBplane)), ...
                squeeze(sim.rgb_comp(i,j,sim.varying_RGBplane,:)), sim.alpha,...
                sim.beta, squeeze(sim.resp_binary(i,j,:)));
            for n = 1:fits.N_runs    
                %use fmincon to search for the optimal defocus
                [fits.ellParam_est(i,j,n,:,s), fits.minVal(i,j,n,s)] = ...
                    fmincon(objectiveFunc_fullM, fits.init(n,:), ...
                    [1,-1,0],0,[],[],fits.lb,fits.ub,fits.nonlcon,options);
            end
            %find the index that corresponds to the minimum value
            [fits.minVal_best(i,j,s),idx_min] = min(fits.minVal(i,j,:,s));
            %find the corresponding optimal focus that leads to the highest peak of
            %the psf's
            fits.ellParam_est_best(i,j,:,s)  = squeeze(fits.ellParam_est(i,j,idx_min,:,s));

            %unscaled circle
            rotMat = [cosd(fits.ellParam_est_best(i,j,3,s)),...
                -sind(fits.ellParam_est_best(i,j,3,s));...
                sind(fits.ellParam_est_best(i,j,3,s)),...
                cosd(fits.ellParam_est_best(i,j,3,s))];
            fits.fullM_fitEllipse_unscaled(i,j,:,:,s) = ...
                (rotMat*(squeeze(1./fits.ellParam_est_best(i,j,1:2,s)).*plt.circleIn2D) + ...
                squeeze(sim.ref_points(i,j,sim.varying_RGBplane)))';
            fits.fullM_fitEllipse_scaled(i,j,:,:,s) = ...
                (squeeze(fits.fullM_fitEllipse_unscaled(i,j,:,:,s)) - ...
                squeeze(sim.ref_points(i,j,sim.varying_RGBplane))').*fits.contour_scaler + ...
                squeeze(sim.ref_points(i,j,sim.varying_RGBplane))';
        end
    end
    fits.minVal_sum(s) = sum(sum(fits.minVal_best(:,:,s)));
end

%% compute the mean and error bars
errbar_lb_idx = 1;
errbar_ub_idx = nDataFiles;
axisRatio_fullM = squeeze((1/fits.ellParam_est_best(:,:,1,:))./(1/fits.ellParam_est_best(:,:,2,:)));
for i = 1:stim.nGridPts_ref  
    for j = 1:stim.nGridPts_ref  
        axisRatio_fullM_sorted = squeeze(sort(axisRatio_fullM(i,j,:), 'ascend'));
        fits.axisRatio_fullM_mean(i,j) = mean(axisRatio_fullM_sorted);
        fits.axisRatio_fullM_lb(i,j) = axisRatio_fullM_sorted(errbar_lb_idx);
        fits.axisRatio_fullM_ub(i,j) = axisRatio_fullM_sorted(errbar_ub_idx);
        
        rotAngle_fullM = deg2rad(squeeze(fits.ellParam_est_best(i,j,3,:)));
        rotAngle_fullM_sorted = sort(rotAngle_fullM, 'ascend');
        fits.rotAngle_fullM_mean(i,j) = mean(rotAngle_fullM_sorted);
        fits.rotAngle_fullM_lb(i,j) = rotAngle_fullM_sorted(errbar_lb_idx);
        fits.rotAngle_fullM_ub(i,j) = rotAngle_fullM_sorted(errbar_ub_idx); 

        [fits.unscaled_contour_CI_ub_fullM(i,j,:,:),...
            fits.unscaled_contour_CI_lb_fullM(i,j,:,:),...
            fits.contour_CI_ub_fullM(i,j,:,:), fits.contour_CI_lb_fullM(i,j,:,:)] = ...
            compute_contour_CI(squeeze(fits.fullM_fitEllipse_unscaled(i,j,:,:,:)),...
            [stim.x_grid_ref(i,j), stim.y_grid_ref(i,j)]);
    end
end

%ground truth
gtM_fitEllipse_unscaled = squeeze(...
    results.fitEllipse_unscaled(sim.slc_fixedVal_idx,...
    sim.slc_RGBplane,:,:,:,:));
gtM_ellParam = squeeze(results.ellParams(sim.slc_fixedVal_idx,...
    sim.slc_RGBplane, :, :,:));

%% visualize it 
plt.ttl = {'GB plane', 'RB plane', 'RG plane'};
if strcmp(sim.method_sampling,'NearContour')
    figName = ['Fitted_Isothreshold_contour_fullM_',plt.ttl{sim.slc_RGBplane},...
        '_sim',num2str(sim.nSims), 'perCond_sampling',sim.method_sampling,...
        '_jitter',num2str(sim.random_jitter)];
elseif strcmp(sim.method_sampling, 'Random')
    figName = ['Fitted_Isothreshold_contour_fullM_',plt.ttl{sim.slc_RGBplane},...
        '_sim',num2str(sim.nSims), 'perCond_sampling',sim.method_sampling,...
        '_range',num2str(sim.range_randomSampling(end))];
end

groundTruth_slc = squeeze(results.fitEllipse_unscaled(sim.slc_fixedVal_idx,...
    sim.slc_RGBplane,:,:,:,:));
for s = 1:nDataFiles
    plot_2D_sampledComp(stim.grid_ref, stim.grid_ref, sim.rgb_comp, ...
        sim.varying_RGBplane,'Random',...
        'EllipsesColor',[178,34,34]./255,...
        'WishartEllipsesColor',[76,153,0]./255,...
        'responses', sim.resp_binary,...
        'groundTruth',groundTruth_slc,...
        'modelPredictions', squeeze(unscaledEllipse(s,:,:,:,:)), ...
        'saveFig',false,...
        'figName',[figName, '_rng',num2str(s)]);    
end

%%
plot_2D_isothreshold_contour(stim.x_grid_ref, stim.y_grid_ref, ...
    results.fitEllipse(sim.slc_fixedVal_idx,...
    sim.slc_RGBplane,:,:,:,:),sim.slc_fixedVal,...
    'slc_x_grid_ref',1:length(stim.grid_ref),...
    'slc_y_grid_ref',1:length(stim.grid_ref),...
    'WishartEllipses_contour_CI',{},...
    'IndividualEllipses_contour_CI',{fits.contour_CI_lb_fullM, fits.contour_CI_ub_fullM},...
    'rgb_background',false,...
    'xlabel',plane_slc(1),...
    'ylabel',plane_slc(2),...
    'refColor',[0,0,0],...
    'EllipsesColor',[178,34,34]./255,...
    'WishartEllipsesColor',[76,153,0]./255,...
    'ExtrapEllipsesColor',[0.5,0.5,0.5],...
    'figPos',[0,0.1,0.35,0.4],...
    'subTitle', {sprintf(['Comparison of the predictions for the iso-threshold contours \nin ',...
        plane_slc, ' between the Wishart model and the ground truth'])},...
    'figName', ['Comparison_IsothresholdContours_fullM_vs_gtM_',plane_slc,'_sim',num2str(sim.nSims),'perCond_',...
            'sampling',sim.method_sampling,'_jitter',num2str(sim.random_jitter),'_rng1to',num2str(nDataFiles)],...
    'saveFig',true);

%% visualize
%ratio between major and minor axis
figName1 = ['Comparison_axisRatio_fullM_vs_gtM_',plane_slc,'_sim',num2str(sim.nSims),'perCond_',...
            'sampling',sim.method_sampling,'_jitter',num2str(sim.random_jitter),'_rng1to',num2str(nDataFiles)];
plot_comparison_WishartM_vs_fullM(squeeze(gtM_ellParam(:,:,2))./squeeze(gtM_ellParam(:,:,1)),...
    fits.axisRatio_fullM_mean,fits.axisRatio_fullM_lb,...
    fits.axisRatio_fullM_ub,[],[],...
    'xlim',[1,7],'ylim',[1,7],'x_ref',stim.grid_ref,'y_ref',stim.grid_ref,...
    'xlabel',sprintf('The ground-truth ratio of major vs. minor axis'),...
    'ylabel',sprintf('The ratio of major vs. minor axis\n computed based on the Wishart Process Model'),...
    'figPos',[0,0.1,0.3,0.5],'paperSize',[25,25],'saveFig',true,'figName',figName1);

%rotation angle
figName2 = ['Comparison_rotAngle_fullM_vs_gtM_',plane_slc,'_sim',num2str(sim.nSims),'perCond_',...
            'sampling',sim.method_sampling,'_jitter',num2str(sim.random_jitter),'_rng1to',num2str(nDataFiles)];
plot_comparison_WishartM_vs_fullM(squeeze(deg2rad(gtM_ellParam(:,:,3))),...
    fits.rotAngle_fullM_mean,fits.rotAngle_fullM_lb,...
    fits.rotAngle_fullM_ub,[],[],...
    'xlim',[0,pi/2],'ylim',[0,pi/2],'x_ref',stim.grid_ref,'y_ref',stim.grid_ref,...
    'xticks',0:pi/8:pi/2, 'yticks',0:pi/8:pi/2, ...
    'xticklabels',{'$0$','$\pi/8$','$\pi/4$','$3\pi/8$','$\pi/2$'},...
    'yticklabels',{'$0$','$\pi/8$','$\pi/4$','$3\pi/8$','$\pi/2$'},...
    'LatexInterpreter',true,...
    'xlabel',sprintf('The ground-truth rotation (in radians)'),...
    'ylabel',sprintf('The rotation (in radians)\n computed based on the Wishart Process Model'),...
    'figPos',[0,0.1,0.3,0.5],'paperSize',[25,25],'saveFig',true,'figName',figName2);


%%
analysisDir = getpref('ColorEllipsoids', 'ELPSAnalysis');
myFigDir = 'ModelFitting_DataFiles';
outputDir = fullfile(analysisDir,myFigDir);
if (~exist('outputDir'))
    mkdir(outputDir);
end

%whether we want to save the seed
flag_saveSeed = true;
if flag_saveSeed; str_extension = ['_rng1to', num2str(nDataFiles)];
else; str_extension = ''; end

if strcmp(sim.method_sampling, 'NearContour')
    fileName = ['Fits_isothreshold_fullM_',plt.ttl{sim.slc_RGBplane},'_sim',...
        num2str(sim.nSims), 'perCond_sampling',sim.method_sampling,...
        '_jitter',num2str(sim.random_jitter),str_extension,'.mat'];
elseif strcmp(sim.method_sampling, 'Random')
    fileName = ['Fits_isothreshold_fullM_',plt.ttl{sim.slc_RGBplane},'_sim',...
        num2str(sim.nSims), 'perCond_sampling',sim.method_sampling,...
        '_range',num2str(sim.range_randomSampling(end)),str_extension,'.mat'];
end
outputName = fullfile(outputDir, fileName);
save(outputName,'fits');








